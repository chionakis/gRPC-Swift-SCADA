// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: telemetry.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Telemetry_TagRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tagNames: [String] = []

  var opcEndpoint: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Telemetry_MultiTagResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tagResponses: [Telemetry_TagResponse] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Telemetry_WriteTagRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of tag names to write to
  var tagNames: [String] = []

  /// Corresponding values for each tag
  var values: [String] = []

  /// OPC UA endpoint
  var opcEndpoint: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Telemetry_TagResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tagName: String = String()

  var value: String = String()

  var timestamp: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Telemetry_WriteTagResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Indicates whether the write operation was successful
  var success: Bool = false

  /// Message indicating success or error
  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Telemetry_HistoryReadTagRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// OPC UA server endpoint
  var opcEndpoint: String = String()

  /// Tag to read historical data for
  var tagNames: [String] = []

  /// Start time in RFC3339 format
  var startTime: String = String()

  /// End time in RFC3339 format
  var endTime: String = String()

  /// Maximum number of values to read
  var maxValues: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Response for historical data
struct Telemetry_HistoryReadTagResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tagName: String = String()

  var value: String = String()

  var timestamp: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Telemetry_EventResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique identifier of the event
  var eventID: String = String()

  /// Event message or description
  var message: String = String()

  /// Event severity level (e.g., alarms, notifications)
  var severity: Int32 = 0

  /// Name of the source that triggered the event
  var sourceName: String = String()

  /// Timestamp of the event (in RFC3339 format)
  var timestamp: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// New message for alarm subscription response
struct Telemetry_AlarmResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eventID: String = String()

  var message: String = String()

  var severity: Int32 = 0

  var sourceName: String = String()

  var activeState: Bool = false

  var ackedState: Bool = false

  var confirmedState: Bool = false

  var timestamp: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// New message for alarm acknowledgment request
struct Telemetry_AcknowledgeAlarmRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of Object IDs to acknowledge
  var objectIds: [String] = []

  /// List of Event IDs to acknowledge
  var eventIds: [String] = []

  /// Optional comment to accompany the acknowledgment
  var comment: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// New message for alarm acknowledgment response
struct Telemetry_AcknowledgeAlarmResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Results for each acknowledged alarm
  var results: [Telemetry_AlarmAcknowledgeResult] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// New message for the result of acknowledging alarms
struct Telemetry_AlarmAcknowledgeResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var objectID: String = String()

  var eventID: String = String()

  var success: Bool = false

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "telemetry"

extension Telemetry_TagRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TagRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tagNames"),
    2: .same(proto: "opcEndpoint"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.tagNames) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.opcEndpoint) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tagNames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tagNames, fieldNumber: 1)
    }
    if !self.opcEndpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.opcEndpoint, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Telemetry_TagRequest, rhs: Telemetry_TagRequest) -> Bool {
    if lhs.tagNames != rhs.tagNames {return false}
    if lhs.opcEndpoint != rhs.opcEndpoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Telemetry_MultiTagResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MultiTagResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tagResponses"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.tagResponses) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tagResponses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tagResponses, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Telemetry_MultiTagResponse, rhs: Telemetry_MultiTagResponse) -> Bool {
    if lhs.tagResponses != rhs.tagResponses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Telemetry_WriteTagRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WriteTagRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tagNames"),
    2: .same(proto: "values"),
    3: .same(proto: "opcEndpoint"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.tagNames) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.values) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.opcEndpoint) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tagNames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tagNames, fieldNumber: 1)
    }
    if !self.values.isEmpty {
      try visitor.visitRepeatedStringField(value: self.values, fieldNumber: 2)
    }
    if !self.opcEndpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.opcEndpoint, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Telemetry_WriteTagRequest, rhs: Telemetry_WriteTagRequest) -> Bool {
    if lhs.tagNames != rhs.tagNames {return false}
    if lhs.values != rhs.values {return false}
    if lhs.opcEndpoint != rhs.opcEndpoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Telemetry_TagResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TagResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tagName"),
    2: .same(proto: "value"),
    3: .same(proto: "timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tagName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.timestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tagName.isEmpty {
      try visitor.visitSingularStringField(value: self.tagName, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    if !self.timestamp.isEmpty {
      try visitor.visitSingularStringField(value: self.timestamp, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Telemetry_TagResponse, rhs: Telemetry_TagResponse) -> Bool {
    if lhs.tagName != rhs.tagName {return false}
    if lhs.value != rhs.value {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Telemetry_WriteTagResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WriteTagResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Telemetry_WriteTagResponse, rhs: Telemetry_WriteTagResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Telemetry_HistoryReadTagRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HistoryReadTagRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "opcEndpoint"),
    2: .same(proto: "tagNames"),
    3: .same(proto: "startTime"),
    4: .same(proto: "endTime"),
    5: .same(proto: "maxValues"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.opcEndpoint) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.tagNames) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.startTime) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.endTime) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.maxValues) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.opcEndpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.opcEndpoint, fieldNumber: 1)
    }
    if !self.tagNames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tagNames, fieldNumber: 2)
    }
    if !self.startTime.isEmpty {
      try visitor.visitSingularStringField(value: self.startTime, fieldNumber: 3)
    }
    if !self.endTime.isEmpty {
      try visitor.visitSingularStringField(value: self.endTime, fieldNumber: 4)
    }
    if self.maxValues != 0 {
      try visitor.visitSingularInt32Field(value: self.maxValues, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Telemetry_HistoryReadTagRequest, rhs: Telemetry_HistoryReadTagRequest) -> Bool {
    if lhs.opcEndpoint != rhs.opcEndpoint {return false}
    if lhs.tagNames != rhs.tagNames {return false}
    if lhs.startTime != rhs.startTime {return false}
    if lhs.endTime != rhs.endTime {return false}
    if lhs.maxValues != rhs.maxValues {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Telemetry_HistoryReadTagResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HistoryReadTagResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tagName"),
    2: .same(proto: "value"),
    3: .same(proto: "timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tagName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.timestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tagName.isEmpty {
      try visitor.visitSingularStringField(value: self.tagName, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    if !self.timestamp.isEmpty {
      try visitor.visitSingularStringField(value: self.timestamp, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Telemetry_HistoryReadTagResponse, rhs: Telemetry_HistoryReadTagResponse) -> Bool {
    if lhs.tagName != rhs.tagName {return false}
    if lhs.value != rhs.value {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Telemetry_EventResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eventId"),
    2: .same(proto: "message"),
    3: .same(proto: "severity"),
    4: .same(proto: "sourceName"),
    5: .same(proto: "timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.eventID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.severity) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.sourceName) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.timestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.eventID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventID, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if self.severity != 0 {
      try visitor.visitSingularInt32Field(value: self.severity, fieldNumber: 3)
    }
    if !self.sourceName.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceName, fieldNumber: 4)
    }
    if !self.timestamp.isEmpty {
      try visitor.visitSingularStringField(value: self.timestamp, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Telemetry_EventResponse, rhs: Telemetry_EventResponse) -> Bool {
    if lhs.eventID != rhs.eventID {return false}
    if lhs.message != rhs.message {return false}
    if lhs.severity != rhs.severity {return false}
    if lhs.sourceName != rhs.sourceName {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Telemetry_AlarmResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AlarmResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eventId"),
    2: .same(proto: "message"),
    3: .same(proto: "severity"),
    4: .same(proto: "sourceName"),
    5: .same(proto: "activeState"),
    6: .same(proto: "ackedState"),
    7: .same(proto: "confirmedState"),
    8: .same(proto: "timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.eventID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.severity) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.sourceName) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.activeState) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.ackedState) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.confirmedState) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.timestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.eventID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventID, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if self.severity != 0 {
      try visitor.visitSingularInt32Field(value: self.severity, fieldNumber: 3)
    }
    if !self.sourceName.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceName, fieldNumber: 4)
    }
    if self.activeState != false {
      try visitor.visitSingularBoolField(value: self.activeState, fieldNumber: 5)
    }
    if self.ackedState != false {
      try visitor.visitSingularBoolField(value: self.ackedState, fieldNumber: 6)
    }
    if self.confirmedState != false {
      try visitor.visitSingularBoolField(value: self.confirmedState, fieldNumber: 7)
    }
    if !self.timestamp.isEmpty {
      try visitor.visitSingularStringField(value: self.timestamp, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Telemetry_AlarmResponse, rhs: Telemetry_AlarmResponse) -> Bool {
    if lhs.eventID != rhs.eventID {return false}
    if lhs.message != rhs.message {return false}
    if lhs.severity != rhs.severity {return false}
    if lhs.sourceName != rhs.sourceName {return false}
    if lhs.activeState != rhs.activeState {return false}
    if lhs.ackedState != rhs.ackedState {return false}
    if lhs.confirmedState != rhs.confirmedState {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Telemetry_AcknowledgeAlarmRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AcknowledgeAlarmRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "objectIds"),
    2: .same(proto: "eventIds"),
    3: .same(proto: "comment"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.objectIds) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.eventIds) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.comment) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objectIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.objectIds, fieldNumber: 1)
    }
    if !self.eventIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.eventIds, fieldNumber: 2)
    }
    if !self.comment.isEmpty {
      try visitor.visitSingularStringField(value: self.comment, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Telemetry_AcknowledgeAlarmRequest, rhs: Telemetry_AcknowledgeAlarmRequest) -> Bool {
    if lhs.objectIds != rhs.objectIds {return false}
    if lhs.eventIds != rhs.eventIds {return false}
    if lhs.comment != rhs.comment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Telemetry_AcknowledgeAlarmResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AcknowledgeAlarmResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "results"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.results) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.results.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.results, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Telemetry_AcknowledgeAlarmResponse, rhs: Telemetry_AcknowledgeAlarmResponse) -> Bool {
    if lhs.results != rhs.results {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Telemetry_AlarmAcknowledgeResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AlarmAcknowledgeResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "objectId"),
    2: .same(proto: "eventId"),
    3: .same(proto: "success"),
    4: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.objectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.eventID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objectID.isEmpty {
      try visitor.visitSingularStringField(value: self.objectID, fieldNumber: 1)
    }
    if !self.eventID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventID, fieldNumber: 2)
    }
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 3)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Telemetry_AlarmAcknowledgeResult, rhs: Telemetry_AlarmAcknowledgeResult) -> Bool {
    if lhs.objectID != rhs.objectID {return false}
    if lhs.eventID != rhs.eventID {return false}
    if lhs.success != rhs.success {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
